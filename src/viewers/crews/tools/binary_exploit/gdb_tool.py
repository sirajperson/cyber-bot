import subprocess
import os
import logging
import shlex
from typing import Type, Any, List
from pydantic import BaseModel, Field
from crewai.tools import BaseTool

logger = logging.getLogger(__name__)

# --- Input Schema ---
class GdbToolInput(BaseModel):
    """Input schema for GdbTool."""
    file_path: str = Field(..., description="The path to the executable file to debug, relative to the '/app/data' directory.")
    gdb_commands: str = Field(..., description="A string containing GDB commands separated by semicolons (e.g., 'break main; run; info registers').")
    # TBD: Add optional 'args' field if needed to pass arguments to the debugged program

class GdbTool(BaseTool):
    name: str = "GDB Batch Executor"
    description: str = (
        "Executes a sequence of GDB commands non-interactively against a specified executable "
        "using GDB's batch mode. Useful for basic dynamic analysis like setting breakpoints, running, "
        "and inspecting registers or memory, primarily for ELF binaries identified by FileTool. "
        "Provide the executable path relative to '/app/data' and GDB commands separated by semicolons."
    )
    args_schema: Type[BaseModel] = GdbToolInput

    def _run(self, file_path: str, gdb_commands: str) -> str:
        """
        Executes GDB in batch mode with the provided commands.
        """
        # --- Security/Context Check ---
        base_dir = "/app/data"
        relative_path = os.path.normpath(os.path.join('/', file_path.lstrip('/'))).lstrip('/')
        target_file = os.path.abspath(os.path.join(base_dir, relative_path))

        if not target_file.startswith(base_dir):
            logger.warning(f"Attempted path traversal: {file_path}")
            return f"Error: Invalid file path '{file_path}'. Path must be within the data directory."
        if not os.path.isfile(target_file):
             logger.error(f"Executable not found for GDB: '{target_file}' (resolved from '{file_path}')")
             return f"Error: Executable file not found at '{target_file}' (resolved from '{file_path}')."
        # Basic check if it's executable (might need refinement based on container setup)
        if not os.access(target_file, os.X_OK):
             # Attempt to make it executable - use with caution, depends on container permissions
             try:
                 os.chmod(target_file, 0o755)
                 logger.info(f"Made file executable: {target_file}")
                 if not os.access(target_file, os.X_OK):
                      raise OSError("chmod succeeded but file still not executable")
             except OSError as e:
                  logger.warning(f"File '{target_file}' is not executable, and chmod failed or was ineffective: {e}")
                  # Return warning but proceed, GDB might still load it for analysis without running
                  # return f"Error: File '{target_file}' is not executable."

        # --- Construct Command ---
        command = ["gdb", "-batch"] # Use batch mode for non-interactive execution

        # Split commands by semicolon and add each as an -ex argument
        cmds = [cmd.strip() for cmd in gdb_commands.split(';') if cmd.strip()]
        if not cmds:
            return "Error: No valid GDB commands provided."

        for cmd in cmds:
            command.extend(["-ex", cmd])

        # Add the executable path using --args (safer for paths with spaces)
        command.extend(["--args", target_file])
        # If args were added to schema: command.extend(program_args_list)

        logger.info(f"Executing command: {' '.join(shlex.quote(c) for c in command)}") # Log safely quoted

        # --- Execute Command ---
        try:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                check=False, # Capture stderr on failure
                timeout=60 # Timeout for GDB execution
            )

            # --- Process Output ---
            output = f"GDB batch execution result for '{file_path}':\n"
            if result.stdout:
                output += f"--- stdout ---\n{result.stdout.strip()}\n"
            else:
                 output += "--- stdout ---\n(No standard output)\n"

            if result.stderr:
                output += f"--- stderr ---\n{result.stderr.strip()}\n"

            output += f"Exit Code: {result.returncode}\n"

            # Limit output length
            max_len = 5000
            if len(output) > max_len:
                output = output[:max_len] + "\n... (output truncated)"

            return output.strip()

        except subprocess.TimeoutExpired:
            logger.error(f"GDB command timed out after 60 seconds for file '{file_path}'.")
            return f"Error: GDB command timed out after 60 seconds on '{file_path}'."
        except FileNotFoundError:
            logger.error("'gdb' command not found. Is it installed in the container PATH?")
            return "Error: 'gdb' command not found. Ensure it is installed in the container."
        except Exception as e:
            logger.error(f"An unexpected error occurred running GDB on '{file_path}': {e}", exc_info=True)
            return f"An unexpected error occurred running GDB: {e}"

# Example usage (for local testing - requires GDB and a simple executable)
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s')
    tool = GdbTool()

    # --- Create a dummy executable in ./data ---
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.abspath(os.path.join(script_dir, '../../../../..'))
    data_dir_abs = os.path.join(project_root, 'data')
    os.makedirs(data_dir_abs, exist_ok=True)

    # Path relative to /app/data
    test_prog_relative = "test_gdb_prog"
    # Absolute path for compiling/deleting
    test_prog_abs = os.path.join(data_dir_abs, test_prog_relative)
    test_c_file = os.path.join(data_dir_abs, "test_gdb_prog.c")

    compile_success = False
    try:
        # Create simple C source
        with open(test_c_file, "w") as f:
            f.write('#include <stdio.h>\nint main() { printf("Hello GDB!\\n"); return 0; }\n')
        print(f"Created dummy C file: {test_c_file}")

        # Compile it (requires gcc to be installed on host)
        compile_cmd = ["gcc", test_c_file, "-o", test_prog_abs]
        print(f"Compiling with: {' '.join(compile_cmd)}")
        compile_result = subprocess.run(compile_cmd, check=True)
        os.chmod(test_prog_abs, 0o755) # Make executable
        print(f"Compiled dummy executable: {test_prog_abs}")
        compile_success = True


        print("\n--- Test 1: Simple run ---")
        # Agent provides path relative to /app/data
        result1 = tool.run(file_path=test_prog_relative, gdb_commands="run")
        print(result1)

        print("\n--- Test 2: Breakpoint and info ---")
        result2 = tool.run(file_path=test_prog_relative, gdb_commands="break main; info breakpoints; run")
        print(result2)

        print("\n--- Test 3: Non-existent file ---")
        result3 = tool.run(file_path="nonexistent_prog", gdb_commands="run")
        print(result3)

        print("\n--- Test 4: Invalid command ---")
        result4 = tool.run(file_path=test_prog_relative, gdb_commands="invalidgdbcommand")
        print(result4)


    except FileNotFoundError:
        print("\n--- Could not compile test executable: 'gcc' not found. Skipping GDB execution tests. ---")
    except subprocess.CalledProcessError as e:
         print(f"\n--- Compilation failed: {e}. Skipping GDB execution tests. ---")
    except Exception as e:
        print(f"\n--- Error during setup: {e}. Skipping GDB execution tests. ---")
    finally:
        # Clean up
        if os.path.exists(test_c_file): os.remove(test_c_file)
        if os.path.exists(test_prog_abs): os.remove(test_prog_abs)
        print(f"\nCleaned up dummy files.")
