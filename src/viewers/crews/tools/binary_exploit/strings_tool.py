import subprocess
import os
import logging
from typing import Type, Any, Optional
from pydantic import BaseModel, Field
from crewai.tools import BaseTool

logger = logging.getLogger(__name__)

# --- Input Schema ---
class StringsToolInput(BaseModel):
    """Input schema for StringsTool."""
    file_path: str = Field(..., description="The path to the binary file to extract strings from, relative to the '/app/data' directory.")
    min_length: int = Field(4, description="Minimum string length to print (default: 4). Corresponds to the '-n' flag.")
    encoding: Optional[str] = Field(None, description="Specify the character encoding. Common values: 's' (ASCII/UTF-8 - default), 'l' (UTF-16LE), 'b' (UTF-16BE). Corresponds to the '-e' flag.")

class StringsTool(BaseTool):
    name: str = "Strings Extractor"
    description: str = (
        "Extracts sequences of printable characters (strings) from any file, typically binaries. "
        "Useful for finding hardcoded passwords, flags, URLs, or other textual hints. "
        "Operates on files within the '/app/data' directory. Provide the file path relative to '/app/data'."
        "You can specify minimum string length and encoding."
    )
    args_schema: Type[BaseModel] = StringsToolInput

    def _run(self, file_path: str, min_length: int = 4, encoding: Optional[str] = None) -> str:
        """
        Executes the 'strings' command on the specified file within the /app/data directory.
        """
        # --- Security/Context Check ---
        base_dir = "/app/data"
        # Sanitize file_path
        relative_path = os.path.normpath(os.path.join('/', file_path.lstrip('/'))).lstrip('/')
        target_file = os.path.abspath(os.path.join(base_dir, relative_path))

        if not target_file.startswith(base_dir):
            logger.warning(f"Attempted path traversal: {file_path}")
            return f"Error: Invalid file path '{file_path}'. Path must be within the data directory."
        if not os.path.isfile(target_file):
             logger.error(f"'strings' command target not found: '{target_file}' (resolved from '{file_path}')")
             return f"Error: File not found at '{target_file}' (resolved from '{file_path}'). Ensure the file exists in /app/data."

        # --- Construct Command ---
        command = ["strings", "-a"] # '-a' scans the whole file

        # Add min length flag if not default
        if min_length > 0 and min_length != 4:
             command.extend(["-n", str(min_length)])

        # Add encoding flag if specified
        valid_encodings = ['s', 'l', 'b', 'L', 'B'] # Add others if needed (e.g., S for UTF-32)
        if encoding and encoding in valid_encodings:
            command.extend(["-e", encoding])
        elif encoding:
             logger.warning(f"Invalid encoding '{encoding}' specified for strings tool. Using default.")
             # Optionally return an error or just proceed with default

        command.append(target_file) # Add the target file path
        logger.info(f"Executing command: {' '.join(command)}")

        # --- Execute Command ---
        try:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                errors='ignore', # Ignore decoding errors for potentially mixed/corrupt strings
                check=False, # Capture stderr on failure
                timeout=60 # Timeout for strings execution
            )

            # --- Process Output ---
            output = f"Strings found in '{file_path}' (min_length={min_length}, encoding={encoding or 'default'}):\n"
            if result.stdout:
                # Add code block formatting for clarity
                output += f"--- stdout ---\n```\n{result.stdout.strip()}\n```\n"
            else:
                 output += "--- stdout ---\n(No strings found matching criteria)\n"

            if result.stderr:
                output += f"--- stderr ---\n{result.stderr.strip()}\n"

            output += f"Exit Code: {result.returncode}\n"

            # Limit output length
            max_len = 8000 # Allow potentially long string dumps
            if len(output) > max_len:
                output = output[:max_len] + "\n... (output truncated)"

            return output.strip()

        except subprocess.TimeoutExpired:
            logger.error(f"'strings' command timed out after 60 seconds for file '{file_path}'.")
            return f"Error: 'strings' command timed out after 60 seconds on '{file_path}'."
        except FileNotFoundError:
            logger.error("'strings' command not found. Is it installed in the container PATH?")
            return "Error: 'strings' command not found. Ensure it is installed in the container."
        except Exception as e:
            logger.error(f"An unexpected error occurred running 'strings' on '{file_path}': {e}", exc_info=True)
            return f"An unexpected error occurred running 'strings': {e}"

# Example usage (for local testing - requires 'strings' command)
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s')
    tool = StringsTool()

    # Determine paths relative to this script file for testing consistency
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.abspath(os.path.join(script_dir, '../../../../..'))
    data_dir_abs = os.path.join(project_root, 'data')
    os.makedirs(data_dir_abs, exist_ok=True)

    # Path relative to /app/data
    test_file_path_relative = "test_strings_file.bin"
    # Absolute path for creating/deleting
    test_file_path_abs = os.path.join(data_dir_abs, test_file_path_relative)

    try:
        # Create a dummy binary file with embedded strings
        with open(test_file_path_abs, "wb") as f:
            f.write(os.urandom(20))
            f.write(b"Hello") # Short string (len 5)
            f.write(os.urandom(10))
            f.write(b"FLAG{This_Is_A_Test_Flag}") # Longer string
            f.write(os.urandom(30))
            f.write(b"AnotherLongStringHere")
            f.write(b"\x00\x01\x02\x03") # Non-printable
            f.write(b"Short") # len 5
            f.write(os.urandom(15))
            # Add UTF-16LE example
            utf16_string = "UTF16-LE-Test".encode('utf-16le')
            f.write(utf16_string)
            f.write(os.urandom(10))

        print(f"Created dummy test file at: {test_file_path_abs}")

        print("\n--- Test 1: Default settings (min_length=4) ---")
        result1 = tool.run(file_path=test_file_path_relative)
        print(result1)

        print("\n--- Test 2: Increased min_length (min_length=10) ---")
        result2 = tool.run(file_path=test_file_path_relative, min_length=10)
        print(result2)

        print("\n--- Test 3: UTF-16LE encoding (encoding='l') ---")
        result3 = tool.run(file_path=test_file_path_relative, encoding='l', min_length=5)
        print(result3)

        print("\n--- Test 4: Non-existent file ---")
        result4 = tool.run(file_path="nosuchfile.bin")
        print(result4)

        print("\n--- Test 5: Invalid path ---")
        result5 = tool.run(file_path="../common/config.py")
        print(result5)

    finally:
        # Clean up
        if os.path.exists(test_file_path_abs): os.remove(test_file_path_abs)
        print(f"\nCleaned up dummy file.")
