import subprocess
import os
import logging
from typing import Type, Any
from pydantic import BaseModel, Field
from crewai.tools import BaseTool

logger = logging.getLogger(__name__)

# --- Input Schema ---
class FileToolInput(BaseModel):
    """Input schema for FileTool."""
    file_path: str = Field(..., description="The path to the file to identify, relative to the '/app/data' directory.")

class FileTool(BaseTool):
    name: str = "File Type Identifier"
    description: str = (
        "Determines the type of a given file (e.g., ELF executable, PE executable, ASCII text, JPEG image, .NET assembly) "
        "using the standard Linux 'file' command. Operates on files within the '/app/data' directory. "
        "Provide the file path relative to '/app/data'."
    )
    args_schema: Type[BaseModel] = FileToolInput

    def _run(self, file_path: str) -> str:
        """
        Executes the 'file' command on the specified file within the /app/data directory.
        """
        # --- Security/Context Check ---
        base_dir = "/app/data"
        # Sanitize file_path
        relative_path = os.path.normpath(os.path.join('/', file_path.lstrip('/'))).lstrip('/')
        target_file = os.path.abspath(os.path.join(base_dir, relative_path))

        if not target_file.startswith(base_dir):
            logger.warning(f"Attempted path traversal: {file_path}")
            return f"Error: Invalid file path '{file_path}'. Path must be within the data directory."
        if not os.path.isfile(target_file):
             logger.error(f"File not found for 'file' command: '{target_file}' (resolved from '{file_path}')")
             return f"Error: File not found at '{target_file}' (resolved from '{file_path}'). Ensure the file exists in /app/data."

        # --- Construct Command ---
        command = ["file", target_file]
        logger.info(f"Executing command: {' '.join(command)}")

        # --- Execute Command ---
        try:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                check=False, # Capture stderr on failure
                timeout=30 # File command should be quick
            )

            # --- Process Output ---
            output = f"File type analysis for '{file_path}':\n"
            if result.stdout:
                # The output format is typically: filename: file type description
                # We can strip the filename part if needed, but returning full output is fine
                output += f"--- stdout ---\n{result.stdout.strip()}\n"
            else:
                 output += "--- stdout ---\n(No standard output)\n"

            if result.stderr:
                output += f"--- stderr ---\n{result.stderr.strip()}\n"

            output += f"Exit Code: {result.returncode}\n"

            # Limit output length (though 'file' output is usually short)
            max_len = 1000
            if len(output) > max_len:
                output = output[:max_len] + "\n... (output truncated)"

            # Check for common failure exit code
            if result.returncode != 0:
                logger.error(f"'file' command failed for {target_file} with exit code {result.returncode}. Stderr: {result.stderr.strip()}")
                # Return the error details captured
            else:
                 logger.info(f"'file' command successful for {target_file}")


            return output.strip()

        except subprocess.TimeoutExpired:
            logger.error(f"'file' command timed out after 30 seconds for file '{file_path}'.")
            return f"Error: 'file' command timed out after 30 seconds on '{file_path}'."
        except FileNotFoundError:
            # This could be either the target file or the 'file' command itself
            logger.error("'file' command not found or target file disappeared. Is 'file' installed and in PATH?")
            return "Error: 'file' command not found or target file disappeared during execution."
        except Exception as e:
            logger.error(f"An unexpected error occurred running 'file' on '{file_path}': {e}", exc_info=True)
            return f"An unexpected error occurred running 'file': {e}"

# Example usage (for local testing - requires 'file' command)
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s')
    tool = FileTool()

    # Determine paths relative to this script file for testing consistency
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.abspath(os.path.join(script_dir, '../../../../..'))
    data_dir_abs = os.path.join(project_root, 'data')
    os.makedirs(data_dir_abs, exist_ok=True)

    # Path relative to /app/data
    test_file_path_relative = "test_file_command.txt"
    test_bin_path_relative = "test_file_command.bin" # For binary test
    # Absolute path for creating/deleting
    test_file_path_abs = os.path.join(data_dir_abs, test_file_path_relative)
    test_bin_path_abs = os.path.join(data_dir_abs, test_bin_path_relative)


    try:
        # Create a dummy text file
        with open(test_file_path_abs, "w") as f:
            f.write("This is a test text file.\n")
        print(f"Created dummy text file at: {test_file_path_abs}")
        # Create a dummy binary file (e.g., simple ELF header start)
        with open(test_bin_path_abs, "wb") as f:
            f.write(b"\x7fELF\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00")
        print(f"Created dummy binary file at: {test_bin_path_abs}")


        print("\n--- Test 1: Identify Text File ---")
        result1 = tool.run(file_path=test_file_path_relative)
        print(result1)

        print("\n--- Test 2: Identify Binary File ---")
        result2 = tool.run(file_path=test_bin_path_relative)
        print(result2)

        print("\n--- Test 3: Non-existent file ---")
        result3 = tool.run(file_path="nonexistent_file.xyz")
        print(result3)

        print("\n--- Test 4: Invalid path ---")
        result4 = tool.run(file_path="../../../etc/hosts")
        print(result4)

    finally:
        # Clean up
        if os.path.exists(test_file_path_abs): os.remove(test_file_path_abs)
        if os.path.exists(test_bin_path_abs): os.remove(test_bin_path_abs)
        print(f"\nCleaned up dummy files.")
