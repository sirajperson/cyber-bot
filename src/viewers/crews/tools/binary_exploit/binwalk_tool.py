import subprocess
import os
from typing import Type, Any, Optional
from pydantic import BaseModel, Field
from crewai.tools import BaseTool
import logging

logger = logging.getLogger(__name__)

# --- Input Schema ---
class BinwalkToolInput(BaseModel):
    """Input schema for BinwalkTool."""
    file_path: str = Field(..., description="The path to the binary file to analyze, relative to the '/app/data' directory.")
    extract: bool = Field(False, description="Set to True to attempt to extract embedded files found (-e flag).")
    depth: Optional[int] = Field(None, description="Scan recursively up to a specified depth (-M flag).")
    extra_args: Optional[str] = Field("", description="Any additional binwalk command line arguments (use with caution).")

class BinwalkTool(BaseTool):
    name: str = "Binwalk File Analyzer"
    description: str = (
        "Analyzes binary files to identify embedded files, file systems, and executable code. "
        "Can optionally attempt to extract found files. Useful for firmware analysis, forensics, and reverse engineering. "
        "Operates on files within the '/app/data' directory."
    )
    args_schema: Type[BaseModel] = BinwalkToolInput

    def _run(self, file_path: str, extract: bool = False, depth: Optional[int] = None, extra_args: Optional[str] = "") -> str:
        """
        Executes the binwalk command on the specified file.
        """
        # --- Security/Context Check ---
        # Ensure the file path is relative and stays within /app/data
        base_dir = "/app/data"
        target_file = os.path.abspath(os.path.join(base_dir, file_path))

        if not target_file.startswith(base_dir):
            return f"Error: Invalid file path '{file_path}'. Path must be relative to the data directory."
        if not os.path.isfile(target_file):
             return f"Error: File not found at '{target_file}' (resolved from '{file_path}')."

        # --- Construct Command ---
        command = ["binwalk"]
        if extract:
            command.append("-e") # Extract files
        if depth is not None and depth > 0:
             # Add Matryoshka flag for recursive extraction
             command.extend(["-M", str(depth)])
        if extra_args:
            # Basic split for extra args, assumes simple arguments
            # WARNING: Avoid complex shell characters here if not using shell=True (which is less safe)
             command.extend(extra_args.split())
        command.append(target_file) # Add the target file path

        logger.info(f"Executing command: {' '.join(command)}")

        # --- Execute Command ---
        try:
            # Use shell=False for security if possible
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                check=False, # Capture stderr on failure
                timeout=180 # Longer timeout for potentially large files/extractions
            )

            # --- Process Output ---
            output = f"Binwalk analysis for '{file_path}':\n"
            if result.stdout:
                output += f"--- stdout ---\n{result.stdout}\n"
            else:
                 output += "--- stdout ---\n(No standard output)\n"

            if result.stderr:
                output += f"--- stderr ---\n{result.stderr}\n"

            output += f"Exit Code: {result.returncode}\n"

            if extract and result.returncode == 0:
                # Binwalk creates an output directory like _filename.extracted
                extract_dir_name = f"_{os.path.basename(target_file)}.extracted"
                extract_dir_path = os.path.join(os.path.dirname(target_file), extract_dir_name)
                # Check if the directory might actually exist
                if os.path.isdir(extract_dir_path):
                     output += f"\nNote: Extraction requested (-e). Check the '{extract_dir_name}' directory within '/app/data' for extracted files."
                else:
                     # Add note even if dir doesn't exist, binwalk might not extract if nothing found
                      output += f"\nNote: Extraction requested (-e). If files were found, they would be in '{extract_dir_name}' within '/app/data'."


            # Limit output length if needed
            max_len = 4000
            if len(output) > max_len:
                output = output[:max_len] + "\n... (output truncated)"

            return output.strip()

        except subprocess.TimeoutExpired:
            logger.error(f"Binwalk command timed out after 180 seconds for file '{file_path}'.")
            return f"Error: Binwalk command timed out after 180 seconds on '{file_path}'."
        except FileNotFoundError:
            logger.error("'binwalk' command not found. Is it installed in the container PATH?")
            return "Error: 'binwalk' command not found. Ensure it is installed in the container."
        except Exception as e:
            logger.error(f"An unexpected error occurred running binwalk on '{file_path}': {e}", exc_info=True)
            return f"An unexpected error occurred running binwalk: {e}"

# Example usage (for local testing - requires binwalk installed and a test file)
if __name__ == "__main__":
    tool = BinwalkTool()

    # --- Create a dummy test file in ./data (relative to script location) ---
    # Create data dir if it doesn't exist
    script_dir = os.path.dirname(__file__)
    data_dir = os.path.join(script_dir, '../../../..', 'data') # Adjust path relative to src/viewers/crews/tools/binary_exploit
    os.makedirs(data_dir, exist_ok=True)
    test_file_path_relative = "test_binwalk_file.bin"
    test_file_path_abs = os.path.join(data_dir, test_file_path_relative)

    try:
        # Simple file with some text and maybe a known signature (e.g., PNG header)
        with open(test_file_path_abs, "wb") as f:
            f.write(b"\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR") # PNG header
            f.write(os.urandom(50)) # Some random data
            f.write(b"This is some text embedded inside.")
            f.write(os.urandom(20))
        print(f"Created dummy test file at: {test_file_path_abs}")

        print("\n--- Test 1: Basic Scan ---")
        result1 = tool.run(file_path=test_file_path_relative)
        print(result1)

        print("\n--- Test 2: Scan with Extraction ---")
        result2 = tool.run(file_path=test_file_path_relative, extract=True)
        print(result2)
        # Check if _test_binwalk_file.bin.extracted directory was created in data/

        print("\n--- Test 3: Non-existent file ---")
        result3 = tool.run(file_path="nonexistent_file.bin")
        print(result3)

        print("\n--- Test 4: Invalid path (trying to escape data dir) ---")
        result4 = tool.run(file_path="../common/config.py") # Example of trying to go up
        print(result4)

    finally:
        # Clean up the dummy file
        if os.path.exists(test_file_path_abs):
            os.remove(test_file_path_abs)
            print(f"\nCleaned up dummy test file: {test_file_path_abs}")
        # Clean up extraction directory if created (simple cleanup)
        extract_dir = os.path.join(data_dir, f"_{test_file_path_relative}.extracted")
        if os.path.isdir(extract_dir):
             import shutil
             shutil.rmtree(extract_dir)
             print(f"Cleaned up extraction directory: {extract_dir}")
