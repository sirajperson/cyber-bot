analyze_binary_challenge:
  description: >
    Analyze the provided CyberSkyline module data ('crawl_data') related to a binary exploitation challenge.
    Focus on the description, any file names or types mentioned, and hints from the VLM markdown or screenshot.
    Develop a step-by-step plan using appropriate reverse engineering tools and techniques to solve the challenge.
    Consider previous feedback ('feedback') if this is a retry attempt.
  expected_output: >
    A clear, step-by-step reverse engineering plan tailored to the specific challenge.
    Example:
    1. Identify file type using the 'file' command.
    2. Run 'strings' on the binary to look for obvious flags or interesting text.
    3. If it's an ELF binary, open it in Ghidra.
    4. Decompile the 'main' function and analyze the program logic.
    5. Look for potential buffer overflows or format string vulnerabilities.

validate_re_plan:
  description: >
    Review the proposed reverse engineering plan ('analysis_text') for correctness and feasibility.
    Check if the suggested tools match the likely file type based on the original challenge context (implicitly available).
    Ensure the steps are logical and cover necessary initial analysis techniques.
  expected_output: >
    A JSON object adhering to the 'AnalysisVerification' Pydantic model, containing:
    - 'valid': boolean (True if the plan is sound, False otherwise).
    - 'feedback': string (Specific, actionable feedback if 'valid' is False, otherwise None or empty).
    Example valid: {"valid": true, "feedback": null}
    Example invalid: {"valid": false, "feedback": "Feedback: The plan suggests Ghidra, but the challenge likely involves a .NET assembly based on the description. Recommend using dnSpy or ILSpy instead."}